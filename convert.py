# A simple python script to convert BlackBerry10 Remember notes backup(backed up using Runisoft Ultimate Backup) .rembkp file to individual note files(txt) that are importable to Standard Notes(compatible with note type text/super)
# Before importing the notes to Standard Notes:
#  You probably also have the note attachments backed up(using Ultimate Backup) to some ATT.../ folder that you need to upload to Standard Notes Files feature in order for attachments to reflect as it is
import os
import html2text
# import urllib3
# from bs4 import BeautifulSoup
import sys
import datetime

import json
import time
import uuid

# Getting the file to process
# file = open("RemBkp20230529165054_.html", "r")
# file = open("RemBkp20230529165054.rembkp", "r")
# # read the modified file
# read_content = file.read()
# # print(read_content)

current_datetime = datetime.datetime.now().strftime("%Y-%m-%d %H-%M-%S")

if len(sys.argv) < 2:
  invarg = True
else:
  invarg = False
  f = sys.argv[1]
  file_name, file_ext = os.path.splitext(f)

# print(file_name)
# print(file_ext)
# exit()

if invarg or file_ext != '.rembkp':
  print("Invalid usage. This program expects a .rembkp file generated by Runisoft Ultimate Backup on a BlackBerry10 device.")
  print("\nUsage:\npython3 " + os.path.basename(__file__) + " RemBkpXXXXXXXXXX.rembkp")
  exit()
else:
  pass

file = open(f, "r")

# # After manually doing required modifications to preserve original formatting as much as possible:
# # 1. Replace all occurences of "<div><br><div>" with "<div><br></div><div>" since this seems to be a formatting mistake by Ultimate Backup
# # 2. Replace all occurences of "<div><br></div>" with "<br>"
# # 3. Replace all occurences of "</div>" with ""
# # 4. Replace all occurences of "<div>" with "<br>"
# # 5. Replace all occurences of "&#13" and "&#10" with "<br>"
# # 6. Remove extra newline/s at the end of the file
# # For my usecase, I have also removed the lines that start with Notes|"Flagged Messages"|, but you can leave them as is if you want

# or automate the modifications:
read_content = file.read()
read_content = read_content.replace("<div><br><div>", "<div><br></div><div>")
read_content = read_content.replace("<div><br></div>", "<br>")
read_content = read_content.replace("</div>", "")
read_content = read_content.replace("<div>", "<br>")
read_content = read_content.replace("&#13", "<br>")
read_content = read_content.replace("&#10", "<br>")
read_content = read_content.strip()

NotesArr = read_content.split('\n') #getting newline separated note entries

print("Total Notes: ",len(NotesArr))

def splitCont(content):
  contArr = content.split('|')
  return contArr


def getNoteText(content):
  #argument in form of html text
  h = html2text.HTML2Text()
  h.ignore_links = False
  # h.ignore_links = True

  noteCont = h.handle(content)
  return noteCont


def writeNote(nName, nText):
    path = './Standard Notes - Importables ' + current_datetime
    if not os.path.exists(path):
      os.makedirs(path)

    j = 1
    tmpnoteName = nName
    while os.path.exists(os.path.join(path, nName + ".txt")):
      nName = tmpnoteName
      nName += "_" + str(j)
      j += 1

    f = open(os.path.join(path, nName + ".txt"), "w")
    f.write(nText)
    f.close()

def getUnixTSfromDate(dStamp):
  # Accepts dStamp in the format "Sat Sep 18 17:27:27 2021"
  localDate = dStamp
  localDate = localDate.partition(' ')[2] # remove Day from localDate
  # print(localDate)

  localUnixTS = time.mktime(datetime.datetime.strptime(localDate, "%b %d %H:%M:%S %Y").timetuple())
  localUnixTS = int(localUnixTS) * 1000000 #SN stores it with microseconds so multiplying with 10^6 # would do it after adjusting localoffset

  # print(localUnixTS)
  # d_UnixTS = localUnixTS
  return localUnixTS

def getISOformat(UnixTS):
  dt = datetime.datetime.utcfromtimestamp(UnixTS / 1000000)
  iso_format = dt.isoformat() + '.000Z'
  # print(iso_format)

  # return iso_format
  # d_iso = iso_format
  return iso_format


def getFilesUuids():
  #requires
  global hasFileList, filesDict, newFilesDict, hasSNimportfile
  filesDict = {}
  newFilesDict = [] #to be used later to Add note uuids to inidividual file entries(the inverse is already acheived), and then later entire fielsDict to be added to 'items'. This enables attachments icon in notes view
  # newFilesArr = []

  path = './Standard Notes Backup and Import File.txt'

  if not os.path.exists(path):
    hasSNimportfile = False
    print('Notice: Could not find \'Standard Notes Backup and Import File.txt\' to get uuid for files uploaded to SN.\nAttachments will not be added and linked to notes automatically.\nRefer to README for more details.')
    return False
  else:
    hasSNimportfile = True
    f = open('Standard Notes Backup and Import File.txt',"r")

  # returns JSON object as 
  # a dictionary
  data = json.load(f)  
  f.close
  count = 1 

  for i in data['items']:
    # print(i)
    if i['content_type'] == "SN|File":
      fName = i['content']['name']
      fUUID = i['uuid']
      # print(fName +": "+ fUUID)
      filesDict[fName] = fUUID

      newFilesDict.append(i)  #idea dropped here as it seems too complex and SN seems to ignore or have no effect if you have 'SN|file' entries in importable json
      # count += 1

  if len(filesDict):
    hasFileList = True
  else:
    hasFileList = False

  # print(json.dumps(newFilesDict))

  # print(json.dumps(filesDict, indent=3)) # print()
  # print("Total of " + str(count) + " Files")
  print("Total of",len(filesDict),"note attachments found.")
  # exit()


getFilesUuids()
# debugging
# exit()



# Super json structure:
# Entire data is inside 'root' key of the json
# 'root' key contains 'children':[], "direction": "ltr", "format": "", "indent": 0, "type": "root", "version": 1
# All data resides inside this children array
# 'children' contains array of 3 jsons, each json again in the format of 'children':[], 'direction', 'format', 'indent', 'type', 'version' 

# 1st json being used for storing noteText as converted by convertNoteText2SuperText inside children[] along with other default values "direction": "ltr", "format": "", "indent": 0, "type": "paragraph", "version": 1
# 2nd json seems to be containing fixed values as "children": [], "direction": "ltr", "format": "", "indent": 0, "type": "paragraph", "version": 1 #maybe useful just to visually separate the text and attachments
# 3rd json being used(only if there are attachments, usually placed at the end of other text data) for storing files details as converted by convertFileList2SuperFormat inside children[] along with other defailt values "direction": null, "format": "", "indent": 0, "type": "paragraph", "version": 1

def convertFileList2SuperFormat(atts):
  #requires atts array as input to be converted to array of json
  #handles #3 as mentioned above in Super json structure
  #and then returning the entire jsonArr for the text part #3

  global refDict, noteText
  
  # print(atts)
  # print(len(atts))
  
  if not atts:
    print("No attachements")
    # exit()
    return False
  else:
    pass
    # print("yes att")
    # exit()

  # getFilesUuids()

  # if 'hasFileList' in globals() and len(atts):
  #   pass
  # else:
  #   return False

  nFDict = {}
  nFDict['children'] = []
  nFDict['direction'] = None #Actually has to be null in json, dumps handles that
  nFDict['format'] = ""
  nFDict['indent'] = 0
  nFDict['type'] = "paragraph"
  nFDict['version'] = 1

  for att in atts:
    # Add attachment to the note the old way if somehow its not present in filesDict, so that user would later know that that particular file should have been there
    if not att in filesDict:
      noteText += '\\n\\n@' + att
      # noteText = noteText.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\b', '\\b').replace('\f', '\\f').replace('\t', '\\t')
      continue

    # pass

    childFormat = '''{{
              "format": "",
              "type": "snfile",
              "version": 1,
              "fileUuid": "{attuuid}",
              "zoomLevel": 50
}}'''

    attuuid = filesDict[att]

    childJson = childFormat.format(attuuid = attuuid)

    try:
      filesJsonArr
    except NameError:
      filesJsonArr = []


    #add json for paragraph to create gaps between attachments
    paraFormat = '''{
            "children": [],
            "direction": null,
            "format": "",
            "indent": 0,
            "type": "paragraph",
            "version": 1
}''' #single { and } since no replacements needed inside

    filesJsonArr.append(json.loads(paraFormat))

    filesJsonArr.append(json.loads(childJson))

    filesJsonArr.append(json.loads(paraFormat))

    #For adding later in the note as 'references' so that each note links to its attachements in SN
    refDict = {}

    refFormat='''{{
               "reference_type": "NoteToFile",
               "content_type": "SN|File",
               "uuid": "{attuuid}"
}}'''

    refJson = refFormat.format(attuuid = attuuid)
      
    try:
      refJsonArr
    except NameError:
      refJsonArr = []

    refJsonArr.append(json.loads(refJson))

    refDict = refJsonArr


  if 'filesJsonArr' in locals():
    nFDict['children'] = filesJsonArr
    return nFDict
    # return json.dumps(nFDict)
  else:
    return False


def convertNoteText2SuperText(str):
  #gets note text as argument, converts it to super format of SN, to be stored in {"root": {"children": [{"children": [] array as separate json entries for each line, separated by json entries for linebreaks themselves(if any)
  #should return array of jsons
  #handles #1 as mentioned above in Super json structure
  #this would typically involve separating noteText by line, if found, separate each line into its own json entry, while adding a separate json entry for newline itself too
  #and then returning the entire jsonArr for the text part #1

  # print(str)
  nTDict = {}
  nTDict['children'] = []
  nTDict['direction'] = "ltr"
  nTDict['format'] = ""
  nTDict['indent'] = 0
  nTDict['type'] = "paragraph"
  nTDict['version'] = 1

  # debugging
  # return 'superTextJson Goes here'

  #json format for each line
  lineFormat = '''{{
              "detail": 0,
              "format": 0,
              "mode": "normal",
              "style": "",
              "text": "{nT}",
              "type": "text",
              "version": 1
}}'''

  lineBreakFormat = '''{{
              "type": "linebreak",
              "version": 1
}}'''
  
  #testing adding entire text with newlines in just one entry
  lineJson = lineFormat.format(nT = str)
  # print(lineJson)
  # exit()

  try:
      linesJsonArr
  except NameError:
      linesJsonArr = []

  linesJsonArr.append(json.loads(lineJson))

  nTDict['children'] = linesJsonArr
  return nTDict
  # return json.dumps(nTDict)




def createSuperNoteJson():
  #creates json to be stored in escaped form as a value for 'text' key as '{noteText}'
  #ie combine all 3 parts mentioned above
  #and return full json to be added to SNjsonArr
  global noteText

  nDict = {}
  nDict['root'] = {}
  nDict['root']['children'] = []
  nDict['root']['direction'] = "ltr"
  nDict['root']['format'] = ""
  nDict['root']['indent'] = 0
  nDict['root']['type'] = "root"
  nDict['root']['version'] = 1

  # first thing it has to call is convertFileList2SuperFormat since that may modify noteText in case of atts, hence convertNoteText2SuperText can be called only after
  # if len(noteAttachments): #otherwise it adds previous note's values of attachementsArr to next note if has no attachments. handled by resetting value of attachmentsArr if there are no attachments for current note
  fDict = convertFileList2SuperFormat(attachmentsArr)

  superTextDict = convertNoteText2SuperText(noteText)

  #add superTextDict to nDict['root']['children']
  nDict['root']['children'].append(superTextDict)
  #add fDict to nDict['root']['children']
  #Although this adds files to notes directly, it doesn't 'Link' the files to the notes automatically. Hence no attachment icon on the note even if attachments are present
  nDict['root']['children'].append(fDict)

  # return nDict
  return json.dumps(nDict)




def createSNjson(notetype='plain-text'):
  # requires variables inside the jsonFormat already set, so that it can be replaced
  # accepts super as an argument, defaults to plain-text as noteType #planned but it seems too complicated to manually code the conversion from plaintext to super note. 
  # Would be suitable if conversion code is available. Even then, you'd still have to open it select the attchment which would still change the file update time. So no point in trying to convert directly to super note
  # better to just manually convert to super from the app itself as mentioned in README of this project

  # Unless, you first get a list of fileUuid associated with each already uploaded file in SN beforehand(maybe from files backup), and then add those in super note format accordingly. That would work perfectly well
  
  global noteText, refDict

  jsonFormat = '''{{
  "content_type": "Note",
  "content": {{
    "title": "{noteName}",
    "text": "{noteText}",
    "noteType": "{noteType}",
    "references": [],
    "appData": {{
      "org.standardnotes.sn": {{
        "client_updated_at": "{updated_d_iso}"
      }}
    }},
    "preview_plain": "{preview_plain}"
  }},
  "created_at_timestamp": {created_ts},
  "created_at": "{created_d_iso}",
  "deleted": false,
  "updated_at_timestamp": {updated_ts},
  "updated_at": "{updated_d_iso}",
  "uuid": "{uuid}"
}}'''
#leaving client_updated_at as it is around creation of this script to let SN know what it wants to know by this ( probably SN version associated with exported data, so that it can import accordingly )
#apparently, client_updated_at is used as modification time shown in a client (and for sorting if set so in settings). So it has to be updated to same as 'updated_at' (value of {updated_d_uso})

  count = 0
  preview_plain = ""
  for line in noteText.splitlines():
    count += 1
    preview_plain += line
    if count == 1:
      preview_plain += "\n"
    if count == 2:
      break

  #truncate it to 35 chars
  preview_plain = (preview_plain[:35] + '..') if len(preview_plain) > 35 else preview_plain
  preview_plain = preview_plain.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\b', '\\b').replace('\f', '\\f').replace('\t', '\\t')

  noteText = noteText.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\b', '\\b').replace('\f', '\\f').replace('\t', '\\t')
  noteVars = {}
  noteVars['noteName'] = noteName

  if notetype.lower() == 'super':
    noteType = 'super'
    noteVars['noteType'] = noteType
    noteText = createSuperNoteJson()
    # print(noteText)
    # debugging
  else:
    noteType = 'plain-text'
    noteVars['noteType'] = 'plain-text'
    #or
    #noteVars['noteType'] = notetype #as provided via argument

  # noteVars['noteText'] = noteText
  # escape newlines and " characters to store in json

  if noteType == 'super':
    noteText = noteText.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\b', '\\b').replace('\f', '\\f').replace('\t', '\\t')
    # noteText = json.dumps(noteText) #should work but quotes entire output again since as once is hardcoded in jsonFormat
  # print(noteText)
  noteVars['noteText'] = noteText
  #weirdly enough, SN does not escape / characters

  noteVars['preview_plain'] = preview_plain

  noteVars['created_ts'] = created_ts
  noteVars['created_d_iso'] = created_d_iso
  noteVars['updated_ts'] = updated_ts
  noteVars['updated_d_iso'] = updated_d_iso
  noteVars['uuid'] = uuid.uuid4()

  SNjson = jsonFormat.format(**noteVars)

  # print(noteVars)

  return SNjson


# SNjsonArr = []

# process each note one by one
for i in NotesArr:
  contArr = splitCont(i);
  contArr = [s.strip('"') for s in contArr] #stripping " from all values
  
  noteName = contArr[2]
  
  # # Test this program for a specific note(name) only
  # if noteName != 'Test Note':
  #   continue

  # Replace '/' and '\' chars with '-' from noteName(since it will be used as file name later on)
  noteName = noteName.replace("\\", "-")
  noteName = noteName.replace("/", "-")
  noteName = noteName.replace("*", "-")
  noteName = noteName.replace(":", "-")
  noteName = noteName.replace("?", "-")


  print("\n\n==========Processing: ", noteName)
  noteText = getNoteText(contArr[3])
  # in some notes with numbered lists, such as 1. its replaced to 1\. by Ultimate Backup. Fixing that:
  noteText = noteText.replace("\\.",".")
  noteText = noteText.replace("\\-","-")

  #Remove this line if its breaking some content in your notes
  noteText = noteText.replace("â€Ž","") # may break some Guj

  noteCtime = contArr[6] #creatiion time
  noteMtime = contArr[7] #modification time
  
  noteAttachments = contArr[8] #or [-5]
  noteAttachmentTypes = contArr[12] #or [-1]
  
  # print(noteName)
  print(noteText)
  print("Created On: " + noteCtime)
  print("Updated On: " + noteMtime)
  # print("Attachments: " + noteAttachments)
  # print("Attachments Types: " + noteAttachmentTypes)

  if len(noteAttachments):
    attachmentsArr = noteAttachments.split(';')
    attachmentsArr = [s.split('/')[1] for s in attachmentsArr]
    print("Attachments: " + noteAttachments)
    print("Attachments Types: " + noteAttachmentTypes)
  
    # Moving this to super format
    # if len(attachmentsArr) and not hasFileList:
    #   for att in attachmentsArr:
    #     noteText += '\n\n@' + att
  else:
    attachmentsArr = []


  # write all notes inside "Standard Notes - Importables" as txt files. Does not preserve timestamps.
  # writeNote(noteName, noteText)
  # commented this method as json method below supportes timestamps and is also much faster when importing


  # Write it as json instead, which preserves timestamps
  created_date = noteCtime
  created_ts = getUnixTSfromDate(created_date)
  created_d_iso = getISOformat(created_ts)

  updated_date = noteMtime
  updated_ts = getUnixTSfromDate(updated_date)
  updated_d_iso = getISOformat(updated_ts)


  # # print(createSNjson())
  # if len(noteAttachments): # and hasFileList:
  #   #use 'super' only if there are attachments
  #   # print(noteText)
  #   SNjson = createSNjson('super')
  #   # print(SNjson)
  #   # print(json.dumps(SNjson))
  #   # exit()
  # else:
  #   # continue #testing only super types for now
  #   SNjson = createSNjson()

  #or can be made 'super' as default if provided by commandline option - 'super' requires presense of a valid 'Standard Notes Backup and Import File.txt' file, otherwise give a warning and fallback to plain-text type
  #or just can be made default
  SNjson = createSNjson('super')

  if 'refDict' in globals():
    # Add refDict created by call to convertFileList2SuperFormat
    SNjsonD = json.loads(SNjson)
    SNjsonD['content']['references'] = refDict
    refDict = [] #so that it doesn't persist through next loop
    SNjson = json.dumps(SNjsonD)

  # print(SNjson)

  try:
    SNjsonArr
  except NameError:
    SNjsonArr = []

  SNjsonArr.append(json.loads(SNjson)) #if not used json.loads, SNjson is added entirely as a string

  # print(SNjsonArr)

  # #PoC for just one note
  # notesDict = {}
  # notesDict['items'] = []
  # # notesDict['items'][0] = SNjson
  # notesDict['items'] = SNjsonArr

  #debuging
  # if len(noteAttachments):
  #   exit()

#PoC for just one note
notesDict = {}
notesDict['items'] = []
# notesDict['items'][0] = SNjson
notesDict['items'] = SNjsonArr
  
# print(notesDict)
# print(json.dumps(notesDict));
SNjsonContent = json.dumps(notesDict, indent = 3)
# print("WRITTEN TO IMPORTABLE JSON AS:")
# print(SNjsonContent)

SNjsonImportFile = "StandardNotes_json.txt"

f = open(SNjsonImportFile, "w")
f.write(SNjsonContent)
f.close()

print("\n================================================")
if not hasSNimportfile:
  print('Notice: Could not find \'Standard Notes Backup and Import File.txt\' to get uuid for files uploaded to SN.\nAttachments will not be added and linked to notes automatically.\nRefer to README for more details.')
  print("================================================")
print("Total Notes: ",len(NotesArr))
print("================================================")
print("SN Importable json is written to " + SNjsonImportFile)
print("================================================\n")
# writeNotes()